package anylayout.extras;

import static anylayout.AnyLayout.useAnyLayout;
import static fpeas.function.FunctionUtility.constant;
import static fpeas.function.FunctionUtility.minus;
import static fpeas.maybe.MaybeUtility.constIfNothing;

import java.awt.Component;
import java.awt.Container;
import java.util.Iterator;
import java.util.NoSuchElementException;

import anylayout.Constraint;
import anylayout.LayoutContext;
import anylayout.SizeCalculator;
import fpeas.function.Function;
import fpeas.function.FunctionUtility;
import fpeas.maybe.Maybe;
import fpeas.maybe.MaybeUtility;
import fpeas.sideeffect.SideEffect;

public final class BorderLayoutEmulationUtility
{
	public static BorderLayoutEmulation useBorderLayoutEmulation(final Container container)
	{
		final Maybe<Component> nothing=MaybeUtility.nothing();
		return useBorderLayoutEmulation(container,nothing,nothing,nothing,nothing,nothing);
	}

	private static BorderLayoutEmulation useBorderLayoutEmulation(final Container container,final Maybe<Component> north,final Maybe<Component> south,final Maybe<Component> east,final Maybe<Component> west,final Maybe<Component> centre)
	{
		container.removeAll();

		final SizeCalculator sizeCalculator=new SizeCalculator()
		{
			public int getHeight()
			{
				return sum(zeroReserve(getPreferredHeight),northSouth())+max(zeroReserve(getPreferredHeight),westCentreEast());
			}

			private Iterable<Maybe<Component>> westCentreEast()
			{
				return cons(west,sequence(centre,east));
			}

			private Iterable<Maybe<Component>> northSouth()
			{
				return sequence(north,south);
			}

			public int getWidth()
			{
				final int width=max(zeroReserve(getPreferredWidth()),northSouth());
				final int centreWidth=sum(zeroReserve(getPreferredWidth()),westCentreEast());
				return Math.max(width,centreWidth);
			}
		};

		useAnyLayout(container,0.5f,0.5f,sizeCalculator,new Function<Component,Constraint>()
		{
			public Constraint run(final Component component)
			{
				throw new UnsupportedOperationException();
			}
		});

		final Function<LayoutContext,Integer> zero=FunctionUtility.constant(0);

		final Function<LayoutContext,Integer> heightOfNorthOrSouth=new Function<LayoutContext,Integer>()
		{
			public Integer run(final LayoutContext context)
			{
				final int numOfComponents=(north==null ? 0 : 1)+(south==null ? 0 : 1)+(east!=null||centre!=null||west!=null ? 1 : 0);

				return Math.min(context.getPreferredSize(),context.getParentSize()/numOfComponents);
			}
		};

		final Function<Component,Function<LayoutContext,Integer>> getStart=new Function<Component,Function<LayoutContext,Integer>>()
		{
			public Function<LayoutContext,Integer> run(final Component component)
			{
				return new Function<LayoutContext,Integer>()
				{
					public Integer run(final LayoutContext context)
					{
						return context.getLayoutInfo(component).getFarOffset();
					}
				};
			}
		};

		final Function<Maybe<Component>,Function<LayoutContext,Integer>> getStartMaybe=new Function<Maybe<Component>,Function<LayoutContext,Integer>>()
		{
			public Function<LayoutContext,Integer> run(final Maybe<Component> maybe)
			{
				return constIfNothing(maybe,zero,getStart);
			}
		};

		final Function<LayoutContext,Integer> widthOfEastOrWest=new Function<LayoutContext,Integer>()
		{
			public Integer run(final LayoutContext context)
			{
				final int multiplier=sizeCalculator.getWidth()-context.getParentSize();
				final Integer preferredSize=context.getPreferredSize();
				return Math.min(preferredSize-multiplier*preferredSize/sizeCalculator.getWidth(),preferredSize);
			}
		};

		MaybeUtility.run(north,new SideEffect<Component>()
		{
			public void run(final Component component)
			{
				container.add(component,ConstraintBuilder.buildConstraint().setLeft(zero).setTop(zero).setWidth(parentSize).setHeight(heightOfNorthOrSouth));
			}
		});

		MaybeUtility.run(south,new SideEffect<Component>()
		{
			public void run(final Component component)
			{
				container.add(component,ConstraintBuilder.buildConstraint().setLeft(zero).setTop(parentSizeMinus(heightOfNorthOrSouth)).setWidth(parentSize).setHeight(heightOfNorthOrSouth));
			}
		});

		final Function<LayoutContext,Integer> parentSize1=new Function<LayoutContext,Integer>()
		{
			public Integer run(final LayoutContext layoutContext)
			{
				return layoutContext.getParentSize();
			}
		};

		final Function<LayoutContext,Integer> heightOfCentral=new Function<LayoutContext,Integer>()
		{
			public Integer run(final LayoutContext context)
			{
				int height=minus(parentSize1,getFarOffset.run(north)).run(context);

				height-=constIfNothing(centre,0,new Function<Component,Integer>()
				{
					public Integer run(final Component component)
					{
						return context.getParentSize()-context.getLayoutInfo(component).getOffset();
					}
				});

				return height;
			}
		};

		MaybeUtility.run(east,new SideEffect<Component>()
		{
			public void run(final Component component)
			{
				container.add(component,ConstraintBuilder.buildConstraint().setLeft(parentSizeMinus(widthOfEastOrWest)).setTop(getStartMaybe.run(north)).setWidth(widthOfEastOrWest).setHeight(heightOfCentral));
			}
		});

		MaybeUtility.run(west,new SideEffect<Component>()
		{
			public void run(final Component component)
			{
				container.add(component,ConstraintBuilder.buildConstraint().setLeft(zero).setTop(getStartMaybe.run(north)).setWidth(widthOfEastOrWest).setHeight(heightOfCentral));
			}
		});

		MaybeUtility.run(centre,new SideEffect<Component>()
		{
			public void run(final Component component)
			{
				final Function<Integer,Integer> ifLessThanZero=new Function<Integer,Integer>()
				{
					public Integer run(final Integer integer)
					{
						return -integer;
					}
				};

				container.add(component,ConstraintBuilder.buildConstraint().setLeft(getStartMaybe.run(west)).setTop(getStartMaybe.run(north)).setWidth(fillBetween(west,east,ifLessThanZero)).setHeight(heightOfCentral));
			}
		});

		return new BorderLayoutEmulation()
		{
			public BorderLayoutEmulation setNorth(final Maybe<Component> north1)
			{
				return useBorderLayoutEmulation(container,north1,south,east,west,centre);
			}

			public BorderLayoutEmulation setSouth(final Maybe<Component> south1)
			{
				return useBorderLayoutEmulation(container,north,south1,east,west,centre);
			}

			public BorderLayoutEmulation setEast(final Maybe<Component> east1)
			{
				return useBorderLayoutEmulation(container,north,south,east1,west,centre);
			}

			public BorderLayoutEmulation setWest(final Maybe<Component> west1)
			{
				return useBorderLayoutEmulation(container,north,south,east,west1,centre);
			}

			public BorderLayoutEmulation setCentre(final Maybe<Component> centre1)
			{
				return useBorderLayoutEmulation(container,north,south,east,west,centre1);
			}
		};
	}

	private static final Function<Maybe<Component>,Function<LayoutContext,Integer>> getFarOffset=new Function<Maybe<Component>,Function<LayoutContext,Integer>>()
	{
		public Function<LayoutContext,Integer> run(final Maybe<Component> maybe)
		{
			final Function<LayoutContext,Integer> constantZero=constant(0);
			return constIfNothing(maybe,constantZero,new Function<Component,Function<LayoutContext,Integer>>()
			{
				public Function<LayoutContext,Integer> run(final Component component)
				{
					return new Function<LayoutContext,Integer>()
					{
						public Integer run(final LayoutContext layoutContext)
						{
							return layoutContext.getLayoutInfo(component).getFarOffset();
						}
					};
				}
			});
		}
		/*	return new Function<LayoutContext,Integer>()
		 {
		 public Integer run(final LayoutContext context)
		 {
		 return maybe.accept(new Function<Component,Integer>()
		 {
		 public Integer run(final Component component)
		 {
		 return context.getLayoutInfo(component).getFarOffset();
		 }
		 },0);
		 }
		 };
		 }*/
	};

	public static Function<LayoutContext,Integer> parentSizeMinus(final Function<LayoutContext,Integer> function)
	{
		return new Function<LayoutContext,Integer>()
		{
			public Integer run(final LayoutContext layoutContext)
			{
				return layoutContext.getParentSize()-function.run(layoutContext);
			}
		};
	}

	private static <T> Iterable<T> sequence(final T first,final T second)
	{
		return new Iterable<T>()
		{
			public Iterator<T> iterator()
			{
				return new Iterator<T>()
				{
					int position;

					public boolean hasNext()
					{
						return 2>position;
					}

					public T next()
					{
						final T answer;

						if (0==position)
							answer=first;
						else
							if (1==position)
								answer=second;
							else
								throw new NoSuchElementException();

						position++;

						return answer;
					}

					public void remove()
					{
						throw new UnsupportedOperationException();
					}
				};
			}
		};
	}

	private static <T> Iterable<T> cons(final T element,final Iterable<T> list)
	{
		return new Iterable<T>()
		{
			public Iterator<T> iterator()
			{
				return new Iterator<T>()
				{
					boolean readFirst;

					final Iterator<T> iterator=list.iterator();

					public boolean hasNext()
					{
						return readFirst ? iterator.hasNext() : true;
					}

					public T next()
					{
						if (!readFirst)
						{
							readFirst=true;
							return element;
						}

						return iterator.next();
					}

					public void remove()
					{
						throw new UnsupportedOperationException();
					}
				};
			}
		};
	}

	private static Function<Component,Integer> getPreferredWidth()
	{
		return new Function<Component,Integer>()
		{
			public Integer run(final Component component)
			{
				return component.getPreferredSize().width;
			}
		};
	}

	private static <T> Function<Maybe<T>,Integer> zeroReserve(final Function<T,Integer> function)
	{
		return new Function<Maybe<T>,Integer>()
		{
			public Integer run(final Maybe<T> maybe)
			{
				return MaybeUtility.constIfNothing(maybe,0,function);
			}
		};
	}

	public static final Function<Component,Integer> getPreferredHeight=new Function<Component,Integer>()
	{
		public Integer run(final Component component)
		{
			return component.getPreferredSize().height;
		}
	};

	private static <Key> int sum(final Function<Key,Integer> get,final Iterable<Key> keys)
	{
		int total=0;

		for (final Key key: keys)
			total+=get.run(key);

		return total;
	}

	private static <Key> int max(final Function<Key,Integer> get,final Iterable<? extends Key> keys)
	{
		int max=0;

		for (final Key key: keys)
			max=Math.max(max,get.run(key));

		return max;
	}

	private static Function<LayoutContext,Integer> fillBetween(final Maybe<Component> from,final Maybe<Component> to,final Function<Integer,Integer> ifLessThanZero)
	{
		return new Function<LayoutContext,Integer>()
		{
			public Integer run(final LayoutContext context)
			{
				final int farOffset=getFarOffset.run(from).run(context);

				int width=context.getParentSize()-farOffset;

				width-=MaybeUtility.constIfNothing(to,0,new Function<Component,Integer>()
				{
					public Integer run(final Component component)
					{
						return context.getLayoutInfo(component).getFarOffset()-context.getLayoutInfo(component).getOffset();
					}
				});

				if (0>width)
					return ifLessThanZero.run(width);

				return width;
			}
		};
	}

	public static final Function<LayoutContext,Integer> parentSize=new Function<LayoutContext,Integer>()
	{
		public Integer run(final LayoutContext context)
		{
			return context.getParentSize();
		}
	};
}